{-# LANGUAGE QuasiQuotes #-}

module Example where

import Language.Atom
import Language.Atom.Unit
import Data.Word
import StringEmbed

spec = example $ Watchdog 10

main :: IO ()
main = do (sched, _, _, _, _) <- compile "example" atomCfg spec
          putStrLn $ reportSchedule sched

atomCfg :: Config
atomCfg = defaults { cFuncName = "atom_tick"
                   , cStateName = "example"
                   , cCode = prePostCode
                   , hCode = prePostHeader
                   , cRuleCoverage = False
                   }

cHeader = [embedStr|
// ---- This source is automatically generated by Atom ----
#include <stdlib.h>
#include <stdio.h>
#include <unistd.h>

#define WATCHDOG_PERIOD 15

static uint64_t watchdog_deadline = WATCHDOG_PERIOD;

static uint16_t voltage = 0;

static bool button_port[16] = { false };

void reset_watchdog(void);
void measure_voltage(void);
// End header
|]

cFooter = [embedStr|
// Start footer
int main(void) {
    while (true) {
        printf("__global_clock = %lu\n", __global_clock);

        if (__global_clock > watchdog_deadline) {
             printf("Watchdog expired!\n");
             exit(1);
        }
        atom_tick();
        usleep(500000);
    }
    return 0;
}

void reset_watchdog(void) {
    printf("Watchdog reset\n");
    watchdog_deadline = __global_clock + WATCHDOG_PERIOD;
}

void measure_voltage(void) {
    voltage = (rand() + rand()) / 2;
}

// End footer
|]

prePostCode :: [Name] -> [Name] -> [(Name, Type)] -> (String, String)
prePostCode _ _ _ = (cHeader, cFooter)

prePostHeader :: [Name] -> [Name] -> [(Name, Type)] -> (String, String)
prePostHeader _ _ _ =
  ( "// ---- This header is automatically generated by Atom ----"
  , "// ---- End automatically-generated header ----"
  )

checkButton :: Word8 -> Atom (V Bool)
checkButton n = atom ("checkButton" ++ show n) $ do
  let port = array' "button_port" Bool
      holdTime = 50
      portN = port ! (Const n)

  held <- word8 "timeHeld" 0
  pressed <- bool "button_pressed" False

  atom "pressed" $ do
    held <== mux (value portN) (value held + 1) 0
    pressed <== (value held >. holdTime)

  return pressed

measureVoltage :: Word16 -> Word16 -> Atom (V Bool)
measureVoltage lower upper = atom "measureVoltage" $ do
  let voltage = word16' "voltage"
      safeTime = 10

  triggered <- bool "voltage_trigger" False
  countdown <- timer "threshold"

  phase 0 $ atom "measure" $ call "measure_voltage"
  phase 1 $ atom "read" $ do
    printIntegralE "voltage" $ value voltage
    atom "checkLower" $ do
      cond (value voltage <. Const lower)
      triggered <== true
      printStrLn "Voltage under threshold!"
    atom "checkUpper" $ do
      cond (value triggered &&. value voltage <=. Const upper)
      printStrLn "Resetting countdown..."
      startTimer countdown safeTime
    atom "checkTimer" $ do
      cond (value triggered &&. timerDone countdown)
      triggered <== false
      printStrLn "Voltage back to normal."

  return triggered

data WatchdogSupport = Watchdog Word8
                     | NoWatchdog

example :: WatchdogSupport -> Atom ()
example wd = atom "example" $ do
  let numButtons = 16
  
  buttons <- mapM checkButton [1..numButtons]

  voltage <- period 2 $ measureVoltage 18000 20000

  case wd of
   Watchdog lim -> period (fromIntegral lim) $ atom "watchdog" $ do
     call "reset_watchdog"
   NoWatchdog   -> return ()
